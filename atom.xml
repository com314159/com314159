<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Jon Guo's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://guozhicheng.com//"/>
  <updated>2016-01-14T01:36:44.000Z</updated>
  <id>http://guozhicheng.com//</id>
  
  <author>
    <name><![CDATA[Jon Guo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[iOS IAP支付虚拟货币的实现方案]]></title>
    <link href="http://guozhicheng.com/2016/01/14/iOS%E8%99%9A%E6%8B%9F%E8%B4%A7%E5%B8%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <id>http://guozhicheng.com/2016/01/14/iOS虚拟货币的实现方案/</id>
    <published>2016-01-14T01:36:44.000Z</published>
    <updated>2016-01-14T01:36:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="In-App_Pruchase_介绍">In-App Pruchase 介绍</h2><p>详细可以参考<a href="https://developer.apple.com/library/ios/documentation/LanguagesUtilities/Conceptual/iTunesConnectInAppPurchase_Guide/Chapters/CreatingInAppPurchaseProducts.html" target="_blank" rel="external">苹果文档</a></p>
<h4 id="简单介绍如下:">简单介绍如下:</h4><p>苹果支付类型分为5种,因为我们的需求是永久出售课程(你可以参考多看),所以不考虑Subscription类型的支付。我们要考虑的是以下两种支付方式：</p>
<ul>
<li><strong>Consumbale：</strong><br>这种类型的购买项目，支付之后消费并且可以再次支付，跨设备无法通过苹果恢复。支付后的产品只能使用一次，如果需要重新使用，需要重新支付。比如游戏里面的金币。</li>
</ul>
<ul>
<li><strong>Non-Consumable：</strong><br>这种类型的购买项目，支付之后苹果会提供恢复的接口，在其他设备用同一个iCloud登陆也可以恢复。支付后的产品可以永久使用，如果跨设备，需要在程序当中自动帮用户恢复支付成功的产品。比如游戏里面的通关。</li>
</ul>
<h2 id="为什么要使用虚拟货币支付">为什么要使用虚拟货币支付</h2><p>以我们的佳学应用为例, 我们是出售视频课程的一个应用, 我们的课程出售之后,用户无需再次购买。以此来理解的话， 应该是使用Non-Consumable来实现。所以Udemy iOS版是使用Non-Consumbale来实现的。用户购买一门课程后， 在其他设备登陆可以通过苹果的接口来恢复购买。但是这种实现有两个缺点：</p>
<h3 id="1-价格只能是固定的">1.价格只能是固定的</h3><p>苹果每次购买的价格是固定的，截止2016年1月12日固定的部分价格表如下（可以登录itunesconnect查询）：</p>
<p><img src="http://7xq0zs.com1.z0.glb.clouddn.com/QQ20160112-0.png" alt="价格表"><br>如果价格固定，产品这边不好对课程进行打折促销，也不方便对课程价格进行定价。Udemy上面的课程价格都是以苹果的固定价格为参考进行定价。</p>
<h3 id="2-每一个课程的购买都需要运营人员去itunesconnect上面创建一个相对应的购买项目">2.每一个课程的购买都需要运营人员去itunesconnect上面创建一个相对应的购买项目</h3><p>IAP的每一个课程都是对应一个购买项目，在支付的过程中AppStore会弹出显示相关的信息。查看Udemy的AppStore信息如下图所示：</p>
<p><img src="http://7xq0zs.com1.z0.glb.clouddn.com/Screen%20Shot%202016-01-12%20at%2022.05.26.png" alt="Udemy"></p>
<p>可以发现1248.00元的课程有很多个， 而且每一个都有一个购买项目存在，这些购买项目都是由运营人员在itunesconnect上面创建的。 每增加一门付费课程，都需要在itunesconnect上面创建一个购买项目。</p>
<h3 id="引入虚拟货币后，完美解决了上面的这两个问题。">引入虚拟货币后，完美解决了上面的这两个问题。</h3><p>虚拟货币的流程如下：以佳学的佳币为例</p>
<p>用户通过AppStore充值购买佳币（1元等于1佳币），用户通过佳币来购买课程。所以课程可以任意金额。我们只提供了6种充值佳币的选择，所以我们只需要在itunesconnect上面创建6个购买项目。这6个购买项目分别为1元，6元，30元，60元，98元，208元。用户可以任意选择来充值。<br>因为我们的课程是永久出售， 所以由我们自己的服务器后台来记录每个用户购买了哪些课程，解决跨设备同步的问题。</p>
<h2 id="具体实现">具体实现</h2><h3 id="1-_在itunesconnect上面创建购买项目。">1. 在itunesconnect上面创建购买项目。</h3><ul>
<li>a.注意供审核的屏幕快照需要填写真实的产品截图，这样审核人员才能知道如何审核。</li>
<li>b.上线后不要随意删除购买的项目，会导致无法购买成功。</li>
</ul>
<h3 id="2-_接入IAP支付">2. 接入IAP支付</h3><p>IAP支付的简单流程如下：</p>
<ol>
<li>iOS客户端以productId(购买项目的ID)通过Api向AppStore发起支付请求</li>
<li>AppStore返回支付结果，如果支付成功，返回receipt</li>
<li>客户端通过Receipt向苹果服务器验证是否是一个正确的Receipt,如果正确客户端认为用户支付成功</li>
</ol>
<p>上面的流程存在以下问题：</p>
<ul>
<li>a. 无法知道是哪个用户ID支付成功的</li>
<li>b. 验证过程放客户端不够安全</li>
</ul>
<p>所以最终我们优化后的流程如下，以下服务端指应用的服务端，非苹果服务器：</p>
<p><br></p>
<h4 id="一-客户端对productId做缓存">一.客户端对productId做缓存</h4><p>比如我们佳学创建了6个支付项目，所以会有6个productId缓存在客户端，可以做策略进行更新。</p>
<p><br></p>
<h4 id="二-客户端以productId向服务端请求生成订单号orderId，该订单号绑定了用户ID，如果productId已经过期或者被删除，客户端向服务端请求更新">二.客户端以productId向服务端请求生成订单号orderId，该订单号绑定了用户ID，如果productId已经过期或者被删除，客户端向服务端请求更新</h4><p><br></p>
<h4 id="三-服务端返回订单号orderId,客户端以orderId，productId向AppStore发起支付请求">三.服务端返回订单号orderId,客户端以orderId，productId向AppStore发起支付请求</h4><p>  请求代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//productId: 购买项目的ID</span></span><br><span class="line"><span class="comment">// orderId: 服务端生成的orderId,绑定了用户ID，这个字段只是额外的字段，苹果只对该字段进行存储，并不会进行逻辑处理</span></span><br><span class="line">   SKProduct *product = [self <span class="string">productForIdentifier:</span>productId];</span><br><span class="line">   <span class="keyword">if</span> (product == nil)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   SKMutablePayment *payment = [SKMutablePayment <span class="string">paymentWithProduct:</span>product];</span><br><span class="line">   <span class="keyword">if</span> ([payment <span class="string">respondsToSelector:</span><span class="annotation">@selector</span>(<span class="string">setApplicationUsername:</span>)])</span><br><span class="line">   &#123;</span><br><span class="line">       payment.applicationUsername = orderId;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   [[SKPaymentQueue defaultQueue] <span class="string">addPayment:</span>payment];</span><br></pre></td></tr></table></figure>
<p>   请求的返回结果在SKPaymentTransactionObserver中，添加方法如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[[SKPaymentQueue defaultQueue]</span> <span class="rule"><span class="attribute">addTransactionObserver</span>:<span class="value">self]</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>注意事项：该observer要在应用一启动就添加，因为如果用户支付成功，但是没有验证receipt成功，将在应用下一次启动通过SKPaymentTransactionObserver的以下函数返回上一次支付成功的结果。如果不在启动时添加，将无法获取上一次支付成功的结果。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>paymentQueue:<span class="params">(<span class="variable">SKPaymentQueue</span> *)</span>queue updatedTransactions:<span class="params">(<span class="variable">NSArray</span> *)</span>transactions</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="四-如果支付成功，返回(SKPaymentTransaction_*)transaction对象">四.如果支付成功，返回(SKPaymentTransaction *)transaction对象</h4><p><br></p>
<h4 id="五-客户端通过receipt、transactionId、userId和orderId向服务器请求验证">五.客户端通过receipt、transactionId、userId和orderId向服务器请求验证</h4><p>参数如下：</p>
<p>获取receipt</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span> *)receiptString &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *receiptURL = [[<span class="built_in">NSBundle</span> mainBundle] appStoreReceiptURL];</span><br><span class="line">    <span class="built_in">NSData</span> *receipt = [<span class="built_in">NSData</span> dataWithContentsOfURL:receiptURL];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!receipt) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [receipt base64EncodedStringWithOptions:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果receipt为nil，可以尝试刷新receipt,刷新 方法如下：<br>如果应用第一次启动时发现有支付失败的订单， 建议先刷新receipt再向服务器验证，保证receipt的有效性。<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_refreshReceiptRequest = [[SKReceiptRefreshRequest alloc] initWithReceiptProperties:@&#123;&#125;]<span class="comment">;</span></span><br><span class="line">_refreshReceiptRequest.delegate = self<span class="comment">;</span></span><br><span class="line">[_refreshReceiptRequest start]<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>注意这样也能获取receipt，但是这个是deprecated,并且这个receipt只包含这一次支付结果（如果有多次支付成功，但是未验证都会在receipt里面），不建议使用，是可以验证成功的。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transaction</span>.transactionReceipt</span><br></pre></td></tr></table></figure>
<p>应用服务器产生的获取orderId，用于记录产生订单时间，绑定用户ID</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orderId = transaction<span class="class">.payment</span><span class="class">.applicationUsername</span></span><br></pre></td></tr></table></figure>
<p>注意：如果支付成功瞬间断网（点完确认支付按钮立即断网，orderId可能会记录不到），下次应用启动恢复这一次支付时orderId是记录不到的。此时我们的做法是如果验证receipt成功，认为是当前登陆用户支付成功（也可能是其他用户支付成功）。<br>我们运营一年多，暂时没有发现这种真实用户产生，希望苹果修复这个Bug。</p>
<p>交易ID，苹果维护的交易ID</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transactionId = <span class="keyword">transaction</span>.transactionIdentifier</span><br></pre></td></tr></table></figure>
<p>用户Id: userId<br>因为orderId可能为nil， 如果userId为nil和orderId都为空,等用户登陆成功再验证</p>
<p><br></p>
<h4 id="六-服务器验证方法">六.服务器验证方法</h4><p>请参考<a href="https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateRemotely.html#//apple_ref/doc/uid/TP40010573-CH104-SW1" target="_blank" rel="external">官方文档</a></p>
<p>服务器为了支持测试环境，应先向正式环境验证，然后如果验证返回码为21007（表明这个receipt是测试环境，测试账号可以通过itunesconnect添加），再向测试环境验证，只要验证成功就认为是成功的。</p>
<p>如果验证成功，会返回以下JSON信息，具体格式请参考以上文档</p>
<p>Bundle Identifier: 请验证是否为你们和应用，如果不是，服务器认为验证失败了</p>
<p>productId（数组）: 服务器根据该购买项目的ID来为用户增加金钱</p>
<p>transactionId（数组）: 交易ID，表明该交易ID已经交易成功了。 因为该receipt可能包含多个成功的交易，所以这个是数组类型</p>
<p>因为可能存在多次支付成功的transactionId，所以这里服务器只认为通过参数请求的这一次transactionId验证成功，其他transactionId先不处理，（当然你也可以一次验证认为多次交易成功，增加多次金币，如果这样做客户端记得结束多个交易），并且给orderId对应的用户增加对应的金币</p>
<p>服务器根据以上信息，返回以下4种状态给客户端：</p>
<ol>
<li>支付成功，客户端结束交易</li>
<li>支付失败，苹果确认认为该receipt是无效的，对应错误码：21000 21002<br>21003，客户端结束交易</li>
<li>支付失败， 苹果认为该receipt是有效的，但是我们服务器认为是无效的。如productId或者Bundle Identifier无法和我们的应用对应。客户端结束交易</li>
<li>确认失败，向苹果确认receipt时超时，客户端不结束交易。</li>
</ol>
<p><br></p>
<h4 id="七-_客户端结束交易">七. 客户端结束交易</h4><p>结束交易后，客户端再也无法查询该交易的receipt,应用启动时，苹果再也不会返回该交易的transaction对象。所以一定要慎重结束交易。<br>结束交易的代码如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//queue为SKPaymentQueue，会通过delegate返回</span></span><br><span class="line"><span class="attr_selector">[queue finishTransaction:transaction]</span>;</span><br></pre></td></tr></table></figure>
<p>所以一定要确认该交易已经成功结束，才去调用以上代码。比如用户的金币已经充值成功。 如果充值成功而没有调用以上代码，那每次应用启动都会弹出一个输入Appstore密码的对话框，用户输入密码后会通过SKPaymentTransactionObserver返回这次交易的transaction</p>
<p>我们的处理是一次向服务器请求只能结束一个交易，如果一个receipt存在多个未验证的交易，需要多次向服务器请求才能结束这些交易。 对于未结束的交易，应用第一次启动时会返回transaction对象，客户端需要先缓存这些transaction对象，如果验证成功后，需要使用transaction对象结束交易。</p>
<h2 id="其他注意事项">其他注意事项</h2><ul>
<li><p>如果一个购买项目未结束交易，下次用户对同一个购买项目发起交易，将不会再扣用户的钱<br>如果以佳学币1元为例，如果用户通过Appstore支付了1元人民币，但是因为某种原因没有验证receipt成功，所以我们没有结束该交易。此时用户如果再次点充值1元佳币，Appstore将弹出对话框：”您已购买此APP项目。此项目将免费恢复”。但是这里有一个Bug，此时有时（你一直充值1元，一直提示免费恢复就会出现）并不会回调SKPaymentTransactionObserver。如果你的应用程序在支付前弹出了一个阻塞式的进度条，因为没有回调，你的进度条将一直在转动。</p>
</li>
<li><p>如果用户在设备A上购买成功，未验证receipt成功，用同样的iCloud账号在B设备上无法获取receipt。所以这种方法，跨设备可能会出问题</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="In-App_Pruchase_介绍">In-App Pruchase 介绍</h2><p>详细可以参考<a href="https://developer.apple.com/library/ios/documentation/LanguagesUtilitie]]>
    </summary>
    
      <category term="iOS开发" scheme="http://guozhicheng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>